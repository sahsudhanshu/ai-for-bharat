"""
Language detection and validation utilities.

Uses Unicode script ranges for lightweight detection.
Supports the 10 Indian languages + Hinglish.
"""
from __future__ import annotations
import re
from typing import Dict, List, Optional, Tuple

# тФАтФА Script detection regexes тФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФА

SCRIPT_PATTERNS: Dict[str, re.Pattern] = {
    "devanagari": re.compile(r"[\u0900-\u097F]"),
    "bengali":    re.compile(r"[\u0980-\u09FF]"),
    "gujarati":   re.compile(r"[\u0A80-\u0AFF]"),
    "gurmukhi":   re.compile(r"[\u0A00-\u0A7F]"),
    "kannada":    re.compile(r"[\u0C80-\u0CFF]"),
    "malayalam":  re.compile(r"[\u0D00-\u0D7F]"),
    "odia":       re.compile(r"[\u0B00-\u0B7F]"),
    "tamil":      re.compile(r"[\u0B80-\u0BFF]"),
    "telugu":     re.compile(r"[\u0C00-\u0C7F]"),
    "latin":      re.compile(r"[A-Za-z]"),
}

# тФАтФА Language тЖТ acceptable scripts тФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФА

LANGUAGE_SCRIPTS: Dict[str, List[str]] = {
    "en": ["latin"],
    "hi": ["devanagari", "latin"],       # Hindi + Hinglish (romanised Hindi)
    "mr": ["devanagari", "latin"],       # Marathi + romanised
    "ml": ["malayalam", "latin"],
    "ta": ["tamil", "latin"],
    "te": ["telugu", "latin"],
    "kn": ["kannada", "latin"],
    "bn": ["bengali", "latin"],
    "gu": ["gujarati", "latin"],
    "or": ["odia", "latin"],
}

LANGUAGE_LABELS: Dict[str, str] = {
    "en": "English",
    "hi": "рд╣рд┐рдиреНрджреА (Hindi)",
    "mr": "рдорд░рд╛рдареА (Marathi)",
    "ml": "р┤ор┤▓р┤пр┤╛р┤│р┤В (Malayalam)",
    "ta": "родрооро┐ро┤рпН (Tamil)",
    "te": "р░др▒Жр░▓р▒Бр░Чр▒Б (Telugu)",
    "kn": "р▓Хр▓ир│Нр▓ир▓б (Kannada)",
    "bn": "ржмрж╛ржВрж▓рж╛ (Bengali)",
    "gu": "ркЧрлБркЬрк░рк╛ркдрлА (Gujarati)",
    "or": "рмУрмбрм╝рм┐рмЖ (Odia)",
}

REJECTION_MESSAGES: Dict[str, str] = {
    "en": "I can only understand English. Please write your message in English. ЁЯЩП",
    "hi": "рдХреГрдкрдпрд╛ рд╣рд┐рдиреНрджреА рдореЗрдВ рд▓рд┐рдЦреЗрдВред рдореИрдВ рдХреЗрд╡рд▓ рд╣рд┐рдиреНрджреА рд╕рдордЭ рд╕рдХрддрд╛ рд╣реВрдБред Hinglish рднреА рдЪрд▓реЗрдЧрд╛! ЁЯЩП",
    "mr": "рдХреГрдкрдпрд╛ рдорд░рд╛рдареАрдд рд▓рд┐рд╣рд╛. рдореА рдлрдХреНрдд рдорд░рд╛рдареА рд╕рдордЬреВ рд╢рдХрддреЛ. ЁЯЩП",
    "ml": "р┤жр┤пр┤╡р┤╛р┤пр┤┐ р┤ор┤▓р┤пр┤╛р┤│р┤др╡Нр┤др┤┐р╡╜ р┤Ор┤┤р╡Бр┤др╡Бр┤Х. р┤Ор┤ир┤┐р┤Хр╡Нр┤Хр╡Н р┤ор┤▓р┤пр┤╛р┤│р┤В р┤ор┤╛р┤др╡Нр┤░р┤ор╡З р┤ор┤ир┤╕р╡Нр┤╕р┤┐р┤▓р┤╛р┤Хр╡В. ЁЯЩП",
    "ta": "родропро╡рпБроЪрпЖропрпНродрпБ родрооро┐ро┤ро┐ро▓рпН роОро┤рпБродрпБроЩрпНроХро│рпН. роОройроХрпНроХрпБ родрооро┐ро┤рпН роороЯрпНроЯрпБроорпЗ рокрпБро░ро┐ропрпБроорпН. ЁЯЩП",
    "te": "р░жр░пр░Ър▒Зр░╕р░┐ р░др▒Жр░▓р▒Бр░Чр▒Бр░▓р▒Л р░░р░╛р░пр░Вр░бр░┐. р░ир░╛р░Хр▒Б р░др▒Жр░▓р▒Бр░Чр▒Б р░ор░╛р░др▒Нр░░р░ор▒З р░Ер░░р▒Нр░ер░ор░╡р▒Бр░др▒Бр░Вр░жр░┐. ЁЯЩП",
    "kn": "р▓жр▓пр▓╡р▓┐р▓Яр│Нр▓Яр│Б р▓Хр▓ир│Нр▓ир▓бр▓жр▓▓р│Нр▓▓р▓┐ р▓мр▓░р│Жр▓пр▓┐р▓░р▓┐. р▓ир▓ир▓Чр│Ж р▓Хр▓ир│Нр▓ир▓б р▓ор▓╛р▓др│Нр▓░ р▓Ер▓░р│Нр▓ер▓╡р▓╛р▓Чр│Бр▓др│Нр▓др▓жр│Ж. ЁЯЩП",
    "bn": "ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржмрж╛ржВрж▓рж╛ржпрж╝ рж▓рж┐ржЦрзБржиред ржЖржорж┐ рж╢рзБржзрзБ ржмрж╛ржВрж▓рж╛ ржмрзБржЭрждрзЗ ржкрж╛рж░рж┐ред ЁЯЩП",
    "gu": "ркХрлГрккрк╛ ркХрк░рлАркирлЗ ркЧрлБркЬрк░рк╛ркдрлАркорк╛ркВ рк▓ркЦрлЛ. рк╣рлБркВ рклркХрлНркд ркЧрлБркЬрк░рк╛ркдрлА рк╕ркоркЬрлА рк╢ркХрлБркВ ркЫрлБркВ. ЁЯЩП",
    "or": "рмжрнЯрм╛рмХрм░рм┐ рмУрмбрм╝рм┐рмЖрм░рнЗ рм▓рнЗрмЦрмирнНрмдрнБред рморнБрмБ рмХрнЗрммрм│ рмУрмбрм╝рм┐рмЖ рммрнБрмЭрм┐рмкрм╛рм░рнЗред ЁЯЩП",
}

# тФАтФА Strip pattern тАФ removes digits, emojis, punctuation for meaningful char count тФА

_STRIP_RE = re.compile(r"[\s\d.,!?;:'\"\-тАФтАУ()\[\]{}/\\@#$%^&*+=~`|<>]+")


def detect_scripts(text: str) -> Dict[str, int]:
    """Return mapping of script name тЖТ count of matching chars."""
    counts: Dict[str, int] = {}
    for script, pattern in SCRIPT_PATTERNS.items():
        matches = pattern.findall(text)
        if matches:
            counts[script] = len(matches)
    return counts


def validate_language(text: str, selected_lang: str) -> Tuple[bool, Optional[str]]:
    """
    Check whether user input is acceptable for the selected language.

    Rules:
      1. Very short input (< 3 meaningful chars) тЖТ always accept
      2. Latin-only input тЖТ always accept (English / Hinglish / transliterated)
      3. If Indic script detected, it must match the selected language
      4. Mixed Latin + matching Indic тЖТ accept (Hinglish-style)
      5. Foreign Indic script тЖТ reject with helpful message

    Returns (accepted: bool, rejection_reason: Optional[str])
    """
    # Strip noise
    stripped = _STRIP_RE.sub("", text)
    # Also strip emojis
    stripped = re.sub(
        r"[\U0001F600-\U0001F64F\U0001F300-\U0001F5FF\U0001F680-\U0001F6FF"
        r"\U0001F1E0-\U0001F1FF\U00002702-\U000027B0\U0001F900-\U0001F9FF"
        r"\U0001FA00-\U0001FA6F\U0001FA70-\U0001FAFF\U00002600-\U000026FF]+",
        "", stripped
    )

    if len(stripped) < 3:
        return True, None

    scripts = detect_scripts(text)
    script_names = list(scripts.keys())

    if not script_names:
        return True, None

    if script_names == ["latin"]:
        return True, None

    acceptable = LANGUAGE_SCRIPTS.get(selected_lang, ["latin"])

    for script in script_names:
        if script == "latin":
            continue
        if script not in acceptable:
            label = LANGUAGE_LABELS.get(selected_lang, selected_lang)
            return False, (
                f"Detected {script} script but selected language is {label}. "
                f"Please write in {label}."
            )

    return True, None


def get_rejection_message(selected_lang: str) -> str:
    """Get user-facing rejection message in the selected language."""
    return REJECTION_MESSAGES.get(selected_lang, REJECTION_MESSAGES["en"])
